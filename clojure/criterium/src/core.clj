(ns core)

(use 'criterium.core)
(import 'java.util.UUID)

(quick-bench (Thread/sleep 1000))
(with-progress-reporting (quick-bench (+ 1 2) :verbose))
(with-progress-reporting (quick-bench (UUID/randomUUID) :verbose))
(quick-bench (UUID/randomUUID) :verbose)
(quick-bench (UUID/randomUUID))
(bench (UUID/randomUUID))

(quick-bench (into {} (filter (comp not nil? val) {:a 1 :b nil :c nil})))
(quick-bench (into {} (filter (fn [e] (not (nil? (val e)))) {:a 1 :b nil :c nil})))
(quick-bench (into {} (filter (fn [e] (not (nil? (second e)))) {:a 1 :b nil :c nil})))
(quick-bench (into {} (filter (fn [[_ v]] (not (nil? v))) {:a 1 :b nil :c nil})))
(quick-bench (into {} (remove (comp nil? val) {:a 1 :b nil :c nil})))
(quick-bench (into {} (remove (comp nil? val)) {:a 1 :b nil :c nil}))

(quick-bench {})
(quick-bench (into {} []))
(quick-bench (hash-map))

(let [c 100000]
  (def ints (map (fn [_]
                   (let [n (rand-int c)]
                     (* n (if (< (rand) 0.5) -1 1))))
                 (range 0 c))))
(def intsv (vec ints))
(type ints)
(type (seq ints))
(type (apply list ints))
(type intsv)
(quick-bench (sort ints))
(quick-bench (sort > ints))
(quick-bench (first ints))
(quick-bench (first intsv))
(quick-bench (last ints))
(quick-bench (last intsv))
(quick-bench (peek intsv))
(quick-bench (nth intsv (dec (count intsv))))
(quick-bench (butlast ints))
(quick-bench (butlast intsv))
(quick-bench (reverse ints))
(quick-bench (reverse intsv))
(quick-bench (vec ints))
(quick-bench (vec intsv))
(quick-bench (count ints))
(quick-bench (count intsv))
(quick-bench (every? neg? ints))
(quick-bench (mapv inc ints))
(quick-bench (reduce conj [] ints))
